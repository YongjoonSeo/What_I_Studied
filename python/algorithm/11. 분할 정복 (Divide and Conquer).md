## 분할 정복 (Divide and Conquer)

- <strong>분할 정복 알고리즘</strong>
  - 분할 (Divide): 문제를 여러 개의 자식 문제로 나눈다.
  - 정복 (Conquer): 더이상 작은 부분으로 나눌 수 없게 되면 나눈 작은 부분을 각각 해결한다.
  - 통합 (Combine): (필요하다면) 각각 해결한 답을 모은다.



- 거듭 제곱 알고리즘

  - a<sup>n</sup>을 구하려고 할 때 a를 n번 곱하는 방법으로 a의 n 거듭제곱을 구할 수 있다. 
    - 시간복잡도: O(n)
  - a<sup>n</sup> = (a<sup>n/2</sup>)<sup>2</sup> = (a<sup>n/4</sup>)<sup>2</sup>)<sup>2</sup> 와 같은 식을 사용하여 절반씩 나누고 그 결과값을 구한 뒤 곱해준다.
    - 시간복잡도: O(logn)

  ```python
  # python 예시 - 분할 정복(1): 거듭 제곱 알고리즘
  
  def Power(num, n):
      global cnt1
      cnt1 += 1
      if n == 0: return 1
      return num * Power(num, n-1)
  
  def Power_DC(num, n):
      global cnt2
      cnt2 += 1
      if n // 2:
          prev = Power_DC(num, n//2)
          if n & 1: return prev * prev * num
          else: return prev * prev
      else:
          if n & 1: return num
          else: return 1
  
  cnt1 = 0
  print(Power(2, 3))
  print(f'세는 횟수: {cnt1}')
  cnt1 = 0
  print(Power(2, 10))
  print(f'세는 횟수: {cnt1}')
  
  cnt2 = 0
  print(Power_DC(2, 3))
  print(f'세는 횟수: {cnt2}')
  
  cnt2 = 0
  print(Power_DC(2, 10))
  print(f'세는 횟수: {cnt2}')
  
  # 출력
  8
  세는 횟수: 4 
  1024
  세는 횟수: 11 # 이까지 Power(num, n)
  8
  세는 횟수: 2 
  1024
  세는 횟수: 4 # 이까지 Power_DC(num, n)
  ```

  





- 퀵 정렬
  - 피봇을 구하는 알고리즘
  - 최악의 경우 시간 복잡도: O(n<sup>2</sup>) - 합병정렬에 비해 좋지못함
    --> 하지만 평균적으로 시간 복잡도가 O(nlogn)이다.

  

  

  

출처: SW Expert Academy - Learn - Course - Programming Intermediate

[SW Expert Academy - Programming Intermediate course](https://swexpertacademy.com/main/learn/course/subjectList.do?courseId=AVuPDN86AAXw5UW6)

